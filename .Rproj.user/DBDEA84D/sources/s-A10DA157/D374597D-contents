#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
# Author: ALVARO CHAO ECIJA

library(shiny)
user <- Sys.getenv("USERPROFILE")
#if(!require(RHRV)){
#  install.packages("RHRV")
#}

#if(!require(biwavelet)){
#  install.packages("biwavelet")
#}

#if(!require(ggplot2)){
#  install.packages("ggplot2")
#}

#if(!require(sandwich)){
#  install.packages("sandwich")
#}


#if(!require(ggpubr)){
#  install.packages("ggpubr")
#}

require("RHRV")
require("biwavelet")
require("ggplot2")
require("sandwich")
require("ggpubr")

package <- paste(user, "\\Desktop\\WaveletPhysiol version Shiny V5", sep ="")
devtools::load_all(package)



# Define UI for application that draws a histogram
ui <- fluidPage(
  

    # Application title
    titlePanel("WaveletPhysiol"),
    

    # Sidebar for data input
    fluidRow(
      column(6,
             wellPanel(h2("Upload data"),
                       p("Upload and store data from a specific subject",
                        style="text-align:justify;color:black;background-color:grey80"),
          
          uiOutput("data_file"),
          tags$hr(),
          radioButtons("separator", "Choose separator", choices = c(Semicolon =";",
                                                                    Comma = ",",
                                                                    Tab ="\t"), selected = ";"),
          tags$hr(),
          radioButtons("preprocessing", "Choose preprocessing algorithm", choices = c("Filter with RHRV and Interpolate",
                                                                                      "Interpolate",
                                                                                      "Do not Interpolate"), selected = "Filter with RHRV and Interpolate"
                       ),
          numericInput("int_freq", "Frequency", value = 4, width = 70),
          tags$hr(),
          textInput("subject_name_input", "Identifiers", value = "Subjects"),
          tags$hr(),
          actionButton("upload_subject_data", "Upload Subject Data")
      )
          
      ),
      column(6,
             
             wellPanel(h2("Studdy settings"),
                       p("Change global settings. These settings are intended to be applied to all analyses
                         to avoid biased comparisons",
                         style="text-align:justify;color:black;background-color:grey80"),
                      textInput("framework_name", "Name", value = "WaveletPhysiol Baroreflex Study"),
                      tags$hr(),
                      selectInput("wavelet", "Wavelet (for Discrete Wavelet Transform)",
                                  choices = c("bl14", "bl20","bs3.1","d2", "d4",
                                              "d8", "d16", "fk4", "fk6", "fk14",
                                              "fk22", "haar", "la8" ,"la16", "la20",
                                              "mb4", "mb8", "mb16", "mb24", "w4"
                                              ), selected = "d4"),
                      tags$hr(),
                      fluidRow(
                               column(4,
                                      numericInput("HF_val", "HF", value = 0.4, min = 0.15, step = 0.001)
                                      ),
                               column(4,
                                      numericInput("LF_val", "LF", value = 0.15, min = 0.04, max = 0.15, step = 0.001)
                                      ),
                               column(4,
                                      numericInput("VLF_val", "VLF", value = 0.04, min = 0, max = 0.04, step = 0.0001)
                               )
                      ),
                      tags$hr(),
                      checkboxInput("use_thr", "Use coherence threshold (for Continuous Wavelet Transform)", 
                                    value = TRUE),
                      checkboxInput("use_weights", "Use wegihted estimates", value = TRUE),
                      tags$hr(),
                      actionButton("change_main_sets", "Change Framework Settings"),
                      tags$hr(),
                      h3("Current settings"),
                      h4(textOutput("text_HF")),
                      h4(textOutput("text_LF")),
                      h4(textOutput("text_wavelet")),
                      h4(textOutput("text_thr")),
                      h4(textOutput("text_weights"))
               
             )
      )
             
    ),
    fluidRow(
      column(6,
             wellPanel(
               h3("Upload / Download Study"),
               br(),
               uiOutput("study_file"),
               actionButton("confirm_study", "Use Uploaded Study"),
               tags$hr(),
               downloadButton("rds", "Download Study")
             )
             ),
      column(6,
             wellPanel(
               # Panel to create Intervals
               h3("Set Intervals"),
               br(),
               textInput("interval_names", "Name the Intervals", value = "Intervals"),
               actionButton("confirm_interval_names", "Confirm Interval Names")
             ))
    ),
    fluidRow(
      column(12,
             wellPanel(
               # Box to display subject info
               h3("Study Info"),
               tags$hr(),
               h4(textOutput("text_globalname")),
               h4(textOutput("text_n")),
               h4(textOutput("text_nintervals")),
               h4(textOutput("text_ntests"))
             ))
    ),
    fluidRow(
      column(12,
             wellPanel(
               # Box to visualize results from individual analyses
               h2("Subject Analysis"),
               tags$hr(),
               fluidRow(
                        column(4,
                               selectInput("subject_input", "Select Subject", 
                                           choices = "No subjects have been loaded")),
                        column(4,
                               selectInput("interval_input", "Select Interval", 
                                           choices = "No intervals have been set")),
                        column(4,
                               selectInput("control_input", "Set Interval as Control", 
                                           choices = "No control has been set"))
                        ),
               h3("Recordings & HRV"),
               tags$hr(),
               #checkboxInput("var", "Causal-filter the time segment", value = FALSE),
               wellPanel(style = "background:white",
                         plotOutput("Raw", brush = "brush_raw", dblclick = "dbc_raw")
               ),
               fluidRow(
                 column(6,
                        h4(textOutput("Estimate_HR")),
                        br(),
                        h4(textOutput("pvalue_HR"))
                 ),
                 column(6,
                        h4(textOutput("Estimate_SBP")),
                        br(),
                        h4(textOutput("pvalue_SBP"))
                 )
               ),
               wellPanel(style = "background:white",
                         plotOutput("LF/HF", brush = "brush_raw", dblclick = "dbc_raw")
               ),
               fluidRow(
                 column(12,
                        h4(textOutput("pvalue_HRV_LFHF"))
               )),
               #h4(textOutput("Estimate_LFHF")),
               wellPanel(style = "background:white",
               fluidRow(
                 column(6, 
                        plotOutput("HF", brush = "brush_raw", dblclick = "dbc_raw")),
                 column(6, 
                        plotOutput("LF", brush = "brush_raw", dblclick = "dbc_raw"))
               )),
               fluidRow(
                 column(6,
                        h4(textOutput("Estimate_HF")),
                        br(),
                        h4(textOutput("pvalue_HRV_HF"))
                 ),
                 column(6,
                        h4(textOutput("Estimate_LF")),
                        br(),
                        h4(textOutput("pvalue_HRV_LF"))
                 )
               ),
               h3("Baroreflex Sensitivity"),
               tags$hr(),
               wellPanel(style = "background:white",
                   fluidRow(
                     column(6, 
                            plotOutput("Analyzed_TF_Plot1", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                              resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                            ),
                     column(6,
                            plotOutput("Analyzed_TF_Plot2", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                              resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                            )
                   ),
                   fluidRow(
                     column(6,
                            h4(textOutput("DWT_Estimate_HF")),
                            br(),
                            h4(textOutput("pvalue_HF"))
                            ),
                     column(6,
                            h4(textOutput("DWT_Estimate_LF")),
                            br(),
                            h4(textOutput("pvalue_LF"))
                            )
                   )
                   
               
               
             ),
             tags$hr(),
             sidebarLayout(
               sidebarPanel(width = 2, style = "height: 90vh, overflow-y: auto;",
                 sliderInput("maxEst_dwt", "Max value", min = 0, max = 200, 
                             value = 60, step = 0.05)
               ),
               mainPanel(style = "background:white", width = 10,
                         plotOutput("ExpectedVals_DWT_Plot"))
             )
             )
             )
),

#fluidRow(
#  column(12,
#         wellPanel(
#           br(),
#           wellPanel(
#             style = "background:white",
#             imageOutput("CWT_plot")
#           )
#         ))
#),

fluidRow(
  column(12,
         wellPanel(
         sidebarLayout(
           sidebarPanel(width = 2, style = "height: 90vh, overflow-y: auto;",
                        sliderInput("coherence_val", "Coherence Threshold", min = 0, max = 1, 
                                    value = 0.5)
           ),
           mainPanel(width = 10,
                     imageOutput("CWT_plot"))
         ),
         h3("Baroreflex Sensitivity"),
         tags$hr(),
         selectInput("phase_rest", "Apply a phase restriction",
                     choices = c("No phase restriction applied", "Restrict to positive phase difference only",
                                 "Restrict to negative phase difference only"
                     ), selected = "No phase restriction applied"),
         br(),
         wellPanel(style = "background:white",
                   fluidRow(
                     column(6, 
                            plotOutput("Analyzed_TF_Plot1_cwt", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                              resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                     ),
                     column(6,
                            plotOutput("Analyzed_TF_Plot2_cwt", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                              resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                     )
                   ),
                   fluidRow(
                     column(6,
                            h4(textOutput("CWT_Estimate_HF")),
                            br(),
                            h4(textOutput("pvalue_HF_cwt"))
                     ),
                     column(6,
                            h4(textOutput("CWT_Estimate_LF")),
                            br(),
                            h4(textOutput("pvalue_LF_cwt"))
                     )
                   )
                   
                   
                   
         ),
         br(),
         h3("Phase shift"),
         br(),
         wellPanel(style = "background:white",
                   fluidRow(
                     column(6, 
                            plotOutput("phase1_cwt", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                                  resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                     ),
                     column(6,
                            plotOutput("phase2_cwt", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                                  resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                     )
                   )
         ),
         br(),
         h3("Causal coupling"),
         br(),
         wellPanel(style = "background:white",
                   plotOutput("GC_total", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                            resetOnNew = TRUE),
                              dblclick = "Analyzed_TF_dbc1"),
                   h4(textOutput("GC_Estimate_total")),
                   br(),
                   h4(textOutput("GCe_total"))
         ),
         wellPanel(style = "background:white",
                   fluidRow(
                     column(6, 
                            plotOutput("GC_HF", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                                  resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                     ),
                     column(6,
                            plotOutput("GC_LF", brush = brushOpts(id = "Analyzed_TF_brush1",
                                                                                  resetOnNew = TRUE),
                                       dblclick = "Analyzed_TF_dbc1")
                     )
                   ),
                   fluidRow(
                     column(6,
                            h4(textOutput("GC_Estimate_HF")),
                            br(),
                            h4(textOutput("GCe_HF"))
                     ),
                     column(6,
                            h4(textOutput("GC_Estimate_LF")),
                            br(),
                            h4(textOutput("GCe_LF"))
                     )
                   )
                   
                   
                   
         )
  )
  )
),

fluidRow(
  column(12,
         wellPanel(
           h3("Test Variables"),
           br(),
           fluidRow(
           column(4, textInput("test_name", "Name the Test", value = "Test")),
           column(4, selectInput("test_var_in_test", "Select testing variable", 
                       choices = "No testing variable has been selected")),
           column(4, selectInput("con_var_in_test", "Select control variable", 
                       choices = "No control variable has been selected"))
           ),
           fluidRow(
           column(4, actionButton("confirm_test", "Test")),
           column(4, checkboxInput("norm_hrv", "Normalize HRV", value = FALSE))
           )
         )
         )
),

fluidRow(
  column(6,
         wellPanel(
           h3("HRV Test Results"),
           selectInput("select_testHRV", "Select test", 
                       choices = "No test has been selected"),
           br(),
           wellPanel(style = "background:white",
                     plotOutput("testing_resultsHRV")
           )
         )),
  column(6,
         wellPanel(
           h3("BRS Test Results"),
           selectInput("select_test", "Select test", 
                       choices = "No test has been selected"),
           br(),
           wellPanel(style = "background:white",
                     plotOutput("testing_results")
           )
         )
    
  )
  
),

fluidRow(
  column(12,
         wellPanel(
             uiOutput("clinic_file"),
             actionButton("load_clin", "Load Clinical Data"),
           br(),
           br(),
           br(),
           fluidRow(
             column(4,
             selectInput("select_variable1", "Select variable", 
                         choices = c("BRS (HF)", "BRS (LF)", "HRV (HF)", "HRV (LF)", "HRV (LF/HF)"))),
             column(4, selectInput("select_variable2", "Select variable", 
                                   choices = "No variable has been selected")),
             column(4,
                    selectInput("select_variable3", "Select clinical variable", 
                                choices = "No clinical variable has been selected"))
           ),
           actionButton("make_linear", "Model variables"),
           br(),
           wellPanel(style = "background:white",
                     plotOutput("plot_linear")
             
           ),
           h4(textOutput("model_stats"))
         )
  )
),

    fluidRow(
      column(12,
             wellPanel(
               h2("Background"),
               br(),
               p("WaveletPhysiol is a software developed for the non-invasively assessment of baroreflex function
                 using wavelet transform techniques. This software allows you to load data from subjects that can be
                 obtained by non-invasive methods, and get an estimate of the distribution of baroreflex modulation in
                 time domain.
                 
                 Two methods are employed in these analyses, which are called Wavelet Transforms. These transforms are
                 able to isolate time-frequency features from (in this case, biological) signals, with much more time resolution
                 than conventional spectral analysis methods.",style="text-align:justify;color:black;background-color:lavender;padding:15px;border-radius:10px"),
               br(),
               tags$hr(),
               h3("Analysis by the means of the Discrete Wavelet Transform (DWT)"),
               p("RHRV is an open source software developed by the university of Vigo. This R package was designed to
                 analyze heart rate variability (HRV) with time and frequency domain methods, including wavelet transforms.
                 The authors of this package developed a spececific computational algorithm derived from this transform, known as
                 Pruned Maximal Overlapped Discrete Wavelet Packet Transform (PMODWPT), which is able to recover with 
                 controlled precission the power distribution in time domain of a signal corresponding to a specific
                 frequency band.",style="text-align:justify;color:black;background-color:lavender;padding:15px;border-radius:10px"),
               br(),
               p("However, as literature shows, frequency domain methods and wavelet transforms are not only useful to analyze
                 HRV, but can also be used to analyze blood pressure in the frequency domain, and thus find the corresponding
                 power transfer relationship between both autonomic variables at the frequency domain. This relationship is what
                 is known as baroreflex function. Regarding wavelet analysis, wavelet transforms have been use to investigate this
                 relationship, specially algorithms known as Continuous Wavelet Transforms (CWT). The DWT has also been used in literature
                 to estimate changes in baroreflex over time. This is why, although the PMODWPT algorithm was initially developed for the
                 analysis of HRV, we thought that because of its interesting properties it could also be a suitable tool for 
                 baroreflex function analysis",style="text-align:justify;color:black;background-color:lavender;padding:15px;border-radius:10px"),
               br(),
               p("This software therefore works in parallel with RHRV and allows data to be transfered to the package. Thanks to a compatibility
                 algorithm, blood preassure data can also be analyzed by RHRV in the frequency domain using the PMODWPT
                 algorithm. Once RHRV has analyzed the data, the results are recovered by this software and the transfer function
                 is calculated as the alpha index, as literature suggests.",style="text-align:justify;color:black;background-color:lavender;padding:15px;border-radius:10px"),
               br(),
               p("To test the properties and advantages of this procedure, we propose the following excercise: using the method
                 suggested by de Boer and Karemaker to simulate blood preassure and heart rate registries, this software is also able
                 to generate data simulations so that you can compare your results with the ones reported by de Boer and Karemaker.
                 To run a simulation, simply go to the Study Settings section, and name your study Simulation, then press the 
                 Change Framework Settings buttom. This will automathically generate estimates calculated from noisy and denoised 
                 simulated registries, which you can visualize at the Subject Analysis section. For this analysis, we suggest the use of the Daubecchies 16 wavelet. Then, compare your results with the
                 ones reported by de Boer (see reference 8 at the References section, at the bottom of this page).",style="text-align:justify;color:black;background-color:yellow;padding:15px;border-radius:10px"),
               br(),
               tags$hr(),
               h3("Analysis by the means of the Continuous Wavelet Transform (CWT)"),
               br(),
               p("To serve as complement of the results obtained from the previously described method, this software also offers the 
                 possibility to analyze the data by the means of the CWT. The CWT transfer function allows time-frequency 
                 localization of not only the gain transfer function, but also its phase. It also calculates a magnitude known
                 as wavelet coherence, which serves as a correlation index between time-frequency features of different variables, and allows you identify
                 which of these features are the most reliable and less contaminated by noise. In order to get reliable estimates,
                 literature suggests using a wavelet coherence threshold of 0.5, and thus considering every time-frequency feature
                 associated with a higher coherence value than the theshold a reliable estimate.",style="text-align:justify;color:black;background-color:lavender;padding:15px;border-radius:10px"),
               
             )
             )
      
    ),
fluidRow(
  column(12,
         wellPanel(
           h2("References"),
           tags$hr(),
           h5("1. Pagani M, Somers V, Furlan R, Dell'Orto S, Conway J, 
              Baselli G, Cerutti S, Sleight P, Malliani A. Changes in autonomic 
              regulation induced by physical training in mild hypertension. 
              Hypertension. 1988;12:600-610"),
           br(),
           h5("2. Mallat SG. A Theory for Multiresolution Signal Decomposition: The
           Wavelet Representation. IEEE Transactions on Pattern Analysis and 
           Machine Intelligence. 1989;11:674-693. https://doi.org/10.1109/34.192463"),
           br(),
           h5("3. Rodriguez-Linares L, Mendez AJ, Lado MJ, Olivieri DN, Vila XA, 
              Gomez-Conde I. An open source tool for heart rate variability 
              spectral analysis. Comput Methods Programs Biomed. 
              2011 Jul;103(1):39-50. doi: 10.1016/j.cmpb.2010.05.012. 
              Epub 2010 Jul 31. PMID: 20674067."),
           br(),
           h5("4. Garcia Martinez CA, Otero Quintana A, Vila XA, Lado Tourino MJ,
              Rodriguez-Linares L, Rodriguez Presedo JM, Mendez Penin AJ. 
              Heart Rate Variability Analysis with the R package RHRV. 
              doi:10.1007/978-3-319-65355-6"),
           br(),
           h5("5. Garcia CA, Otero A, Vila X, Marquez DG. A new algorithm for 
              wavelet-based heart rate variability analysis. Biomedical Signal 
              Processing and Control. 2013;8(6):542-50."),
           br(),
           h5("6. Nowak JA, Ocon A, Taneja I, Medow MS, Stewart JM. Multiresolution 
              wavelet analysis of time-dependent physiological responses in syncopal 
              youths. Am J Physiol Heart Circ Physiol. 2009;296(1):H171-H179. 
              doi:10.1152/ajpheart.00963.2008"),
           br(),
           h5("7. Ducla-Soares JL, Santos-Bento M, Laranjo S, Andrade A, Ducla-Soares E, 
              Boto JP, Silva-Carvalho L, Rocha I. Wavelet analysis of autonomic outflow
              of normal subjects on head-up tilt, cold pressor test, Valsalva manoeuvre 
              and deep breathing. Exp Physiol. 2007 Jul;92(4):677-86. 
              doi: 10.1113/expphysiol.2007.038026. Epub 2007 Apr 27. PMID: 17468200."),
           br(),
           h5("8. De Boer RW, Karemaker JM. Cross-Wavelet Time-Frequency Analysis 
              Reveals Sympathetic Contribution to Baroreflex Sensitivity as Cause 
              of Variable Phase Delay Between Blood Pressure and Heart Rate. 
              Front Neurosci. 2019 Jul 9;13:694. doi: 10.3389/fnins.2019.00694. 
              PMID: 31338017; PMCID: PMC6629771."),
           br(),
           h5("9. Torrence C, Compo GP. A practical guide to wavelet analysis. 
              Bull Am Meteorol Soc. 1998;79:61-78"),
           br(),
           h5("10. Keissar K, Maestri R, Pinna GD, La Rovere MT, Gilad O. Non-invasive
              baroreflex sensitivity assessment using wavelet transfer function-based 
              time-frequency analysis. Physiol Meas. 2010 Jul;31(7):1021-36. 
              doi: 10.1088/0967-3334/31/7/011. Epub 2010 Jun 28. PMID: 20585147."),
           br(),
           h5("11. Gouhier TC, Grinsted A, Simko V. R package biwavelet: Conduct 
           Univariate and Bivariate Wavelet Analyses. 
           2019. https://github.com/tgouhier/biwavelet"),
           tags$hr()
           
         )
  )
)

)


# Server of the program
server <- function(input, output, session) {
  options(shiny.maxRequestSize = 100*1024^2) # To change default size for uploaded data
  output$data_file <- renderUI({
    fileInput("data_file", "Upload data file",
              multiple = TRUE, accept = c("text/csv",
                                           "text/comma-separated-values", "text/plain",
                                           ".csv", ".txt"))
  })
  output$study_file <- renderUI({
    fileInput("study_file", "Upload study file",
              multiple = FALSE, accept = ".RDS")
  })
  output$clinic_file <- renderUI({
    fileInput("clinic_file", "Upload clinical data",
              multiple = FALSE, accept = c("text/csv",
                                          "text/comma-separated-values", "text/plain",
                                          ".csv", ".txt"))
  })
  
  
  
  database <- reactiveValues()
  RAW_database <- reactiveValues()
  framework <- BuildStructure(name = "WaveletPhysiol Baroreflex Study")
  database$framework <- framework
  RAW_database$RAW <- framework
  text_globalname <- paste("Name of this study:", isolate(database$framework)$Name)
  text_n <- paste("Number of subjects contained in this study:", isolate(database$framework)$n, "subjects.")
  text_nintervals <- paste("Number of intervals analyzed in this study: ", length(isolate(database$framework)$ExpectedVals), "intervals.")
  text_ntests <- paste("Number of tests performed:", length(isolate(database$framework)$Tests), "tests.")
  text_HF <- paste("HF Interval: from", framework$"General Data"$HF, "to", framework$"General Data"$LF, "Hz.")
  text_LF <- paste("LF Interval: from", framework$"General Data"$LF, "to", framework$"General Data"$VLF, "Hz.")
  text_wavelet <- paste("DWT wavelet:", framework$"General Data"$Wavelet)
  text_thr <- "A coherence threshold is being used to calculate the estimates."
  text_weights <- "Results are being weighted for estimate calculations."
  output$text_globalname <- renderText({text_globalname})
  output$text_n <- renderText({text_n})
  output$text_nintervals <- renderText({text_nintervals})
  output$text_ntests <- renderText({text_ntests})
  output$text_HF <- renderText({text_HF})
  output$text_LF <- renderText({text_LF})
  output$text_wavelet <- renderText({text_wavelet})
  output$text_thr <- renderText({text_thr})
  output$text_weights <- renderText({text_weights})
  
  
  # Update Numeric Outputs for Band Limits:
  
  observeEvent(input$LF_val, {
    updateNumericInput(session, "VLF_val", "VLF", value = input$VLF_val, min = 0, max = input$LF_val, step = 0.0001)
    updateNumericInput(session, "HF_val", "HF", value = input$HF_val, min = input$LF_val, step = 0.001)
  })
  observeEvent(input$VLF_val, {
    updateNumericInput(session, "LF_val", "LF", value = input$LF_val, min = input$VLF_val, max = input$HF_val, step = 0.001)
  })
  
  # Code for downloading study:
  
  output$rds <- 
    downloadHandler(
      filename = function(){
        paste(isolate(database$framework)$Name, ".RDS", sep = "")
      },
      content = function(file){
        framework <- isolate(database$framework)
        RAW <- isolate(RAW_database$RAW)
        analyses <- ShowIndexes(RAW, "analyses")[2,]
        if(length(analyses) > 0){
          for(n in 1:length(analyses)){
            framework$Analyses[[n]]$Data <- RAW$Analyses[[n]]$Data
            framework <- AnalyzeTransferFun(framework, n)
          }
        }
        if(length(framework$ExpectedVals) > 0){
          framework <- PrepareIntervalSlots(framework, "dwt")
          framework <- PrepareIntervalSlots(framework, "cwt")
        }
        saveRDS(framework, file  = file)
      }
    )

  
  # Change Study Settings
  observeEvent(input$change_main_sets, {
    framework <- isolate(database$framework)
    framework$Name <- input$framework_name
    output$text_globalname <- renderText({paste("Name of this study:",framework$Name)})
    framework$"General Data"$Wavelet <- input$wavelet
    framework$"General Data"$Threshold <- input$use_thr
    framework$"General Data"$Weight <- input$use_weights
    framework$"General Data"$HF <- input$HF_val
    framework$"General Data"$LF <- input$LF_val
    framework$"General Data"$VLF <- input$VLF_val
    # Allow usage of simulation
    if(framework$Name == "Simulation"){
      RAW <- isolate(RAW_database$RAW)
      nosySim <- InterpolateData(DataSimulation())
      denoisedSim <- InterpolateData(DataSimulation(use.noise = FALSE))
      framework <- AddAnalysis(framework, name = "Simulation with noisy signals")
      framework <- AddDataToAnalysis(framework, length(framework$Analyses),
                                     time = nosySim$Time, RR = nosySim$RR,
                                     SBP = nosySim$SBP)
      RAW <- AddAnalysis(RAW, name = "Simulation with noisy signals")
      RAW <- AddDataToAnalysis(RAW, length(RAW$Analyses),
                                     time = nosySim$Time, RR = nosySim$RR,
                                     SBP = nosySim$SBP)
      framework <- AnalyzeTransferFun(framework, length(framework$Analyses))
      framework <- AddAvgCwtData(framework, length(framework$Analyses))
      framework <- AddCausalCoupling(framework, length(framework$Analyses))
      framework <- AddAnalysis(framework, name = "Simulation with denoised signals")
      framework <- AddDataToAnalysis(framework, length(framework$Analyses),
                                     time = denoisedSim$Time, RR = denoisedSim$RR,
                                     SBP = denoisedSim$SBP)
      RAW <- AddAnalysis(RAW, name = "Simulation with denoised signals")
      RAW <- AddDataToAnalysis(RAW, length(RAW$Analyses),
                               time = denoisedSim$Time, RR = denoisedSim$RR,
                               SBP = denoisedSim$SBP)
      RAW_database$RAW <- RAW
      framework <- AnalyzeTransferFun(framework, length(framework$Analyses))
      framework <- AddAvgCwtData(framework, length(framework$Analyses))
      framework <- AddCausalCoupling(framework, length(framework$Analyses))
      new_analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      updateSelectInput(session, "subject_input", "Select Subject", choices = new_analysis_choices)
      text_n <- paste("Number of subjects contained in this study:", framework$n, "subjects.")  
      output$text_n <- renderText({text_n})
    }
    text_wavelet <- paste("DWT wavelet:", framework$"General Data"$Wavelet)
    text_thr <- ifelse(framework$"General Data"$Threshold, "A coherence threshold is being used to calculate the estimates.",
                       "No coherence threshold is being used to calculate the estimates.")
    text_weights <- ifelse(framework$"General Data"$Weight, "Results are being weighted for estimate calculations.",
                           "Results are not being weighted for estimate calculations.")
    text_HF <- paste("HF Interval: from", framework$"General Data"$HF, "to", framework$"General Data"$LF, "Hz.")
    text_LF <- paste("LF Interval: from", framework$"General Data"$LF, "to", framework$"General Data"$VLF, "Hz.")
    output$text_HF <- renderText({text_HF})
    output$text_LF <- renderText({text_LF})
    output$text_wavelet <- renderText({text_wavelet})
    output$text_thr <- renderText({text_thr})
    output$text_weights <- renderText({text_weights})
    database$framework <- framework
  })
  
  # Load Study:
  
  observeEvent(input$confirm_study, {
    req(input$study_file)
    framework <- readRDS(input$study_file$datapath)
    output$study_file <- renderUI({
      fileInput("study_file", "Upload study file",
                multiple = FALSE, accept = c(".RDS"))
    })
    text_globalname <- paste("Name of this study:", framework$Name)
    text_n <- paste("Number of subjects contained in this study:", framework$n, "subjects.")
    text_nintervals <- paste("Number of intervals analyzed in this study: ", length(framework$ExpectedVals), "intervals.")
    text_ntests <- paste("Number of tests performed:", length(framework$Tests), "tests.")
    text_HF <- paste("HF Interval: from", framework$"General Data"$HF, "to", framework$"General Data"$LF, "Hz.")
    text_LF <- paste("LF Interval: from", framework$"General Data"$LF, "to", framework$"General Data"$VLF, "Hz.")
    text_wavelet <- paste("DWT wavelet:", framework$"General Data"$Wavelet)
    text_thr <- "A coherence threshold is being used to calculate the estimates."
    text_weights <- "Results are being weighted for estimate calculations."
    if(length(framework$Analyses) > 0) new_analysis_choices <- ShowIndexes(framework, "analyses")[2,]
    if(length(framework$ExpectedVals) > 0) new_interval_choices <- ShowIndexes(framework, "intervals")[2,]
    if(length(framework$Tests) > 0) new_test_choices <- ShowIndexes(framework, "tests")[2,]
    output$text_globalname <- renderText({text_globalname})
    output$text_n <- renderText({text_n})
    output$text_nintervals <- renderText({text_nintervals})
    output$text_ntests <- renderText({text_ntests})
    output$text_HF <- renderText({text_HF})
    output$text_LF <- renderText({text_LF})
    output$text_wavelet <- renderText({text_wavelet})
    output$text_thr <- renderText({text_thr})
    output$text_weights <- renderText({text_weights})
    if(length(framework$Analyses) > 0) updateSelectInput(session, "subject_input", "Select Subject", choices = new_analysis_choices)
    if(length(framework$ExpectedVals) > 0) updateSelectInput(session, "interval_input", "Select Interval", choices = c("No intervals have been set", new_interval_choices))
    if(length(framework$ExpectedVals) > 0) updateSelectInput(session, "control_input", "Set Interval as Control", choices = c("No control has been set", new_interval_choices))
    if(length(framework$ExpectedVals) > 0) updateSelectInput(session, "test_var_in_test", "Select testing variable", choices = c("No testing variable has been selected", new_interval_choices))
    if(length(framework$ExpectedVals) > 0) updateSelectInput(session, "con_var_in_test", "Select control variable", choices = c("No control variable has been selected", new_interval_choices))
    if(length(framework$ExpectedVals) > 0) updateSelectInput(session, "select_variable2", "Select variable", choices = c("No variable has been selected", new_interval_choices))
    if(length(framework$Tests) > 0) updateSelectInput(session, "select_test", "Select test", choices = c("No test has been selected", new_test_choices))
    if(length(framework$TestsHRV) > 0) updateSelectInput(session, "select_testHRV", "Select test", choices = c("No test has been selected", new_test_choices))
    if(length(framework$Clinical) > 0){
      clinic_names <- names(framework$Clinical[1,])[-1]
      updateSelectInput(session, "select_variable3", "Select clinical variable", choices = c("No clinical variable has been selected", clinic_names))
    } 
    database$framework <- framework
    RAW_database$RAW <- framework
  })
  
  # Create Intervals
  
  observeEvent(input$confirm_interval_names, {
    framework <- isolate(database$framework)
    names <- strsplit(input$interval_names, ", ")[[1]]
    if(names[1] != "Intervals"){
      for(n in 1:length(names)){
        framework <- AddTimeInterval(framework, name = names[n])
      }
      text_nintervals <- paste("Number of intervals analyzed in this study: ", length(framework$ExpectedVals), "intervals.")
      output$text_nintervals <- renderText({text_nintervals})
      choices <- ShowIndexes(framework, "intervals")[2,]
      updateSelectInput(session, "interval_input", "Select Interval", choices = c("No intervals have been set", choices))
      updateSelectInput(session, "control_input", "Set Interval as Control", choices = c("No control has been set", choices))
      updateSelectInput(session, "test_var_in_test", "Select testing variable", choices = c("No testing variable has been selected", choices))
      updateSelectInput(session, "con_var_in_test", "Select control variable", choices = c("No control variable has been selected", choices))
      updateSelectInput(session, "select_variable2", "Select variable", choices = c("No variable has been selected", choices))
      framework <- PrepareIntervalSlots(framework, "dwt")
      framework <- PrepareIntervalSlots(framework, "cwt")
      database$framework <- framework
    }
  })
  
  # Load data into Subject Slot
  observeEvent(input$upload_subject_data, {
    names <- strsplit(input$subject_name_input, ", ")[[1]]
    framework <- isolate(database$framework)
    RAW <- isolate(RAW_database$RAW)
    req(input$data_file)
    if(nrow(input$data_file) == length(names)){
      N <- length(names)
      for(n in 1:N){
        if(tools::file_ext(input$data_file[[n, "datapath"]]) == "csv"){
        data <- read.csv(input$data_file[[n, "datapath"]],
                         header = TRUE, sep = input$separator,
                         quote  ="")
        } else if(tools::file_ext(input$data_file[[n, "datapath"]]) == "txt"){
          data <- read.table(input$data_file[[n, "datapath"]], header = TRUE)
          data$Time <- cumsum(data$Time)
        }
        if(input$preprocessing == "Interpolate"){
          #data <- PreprocessData(data, use.RHRV = FALSE)
          data <- InterpolateData(data, input$int_freq)
        } else if(input$preprocessing == "Filter with RHRV and Interpolate"){
          data <- PreprocessData(data, use.RHRV = TRUE)
          data <- InterpolateData(data, input$int_freq)
        }
        framework <- AddAnalysis(framework, name = names[[n]])
        framework <- AddDataToAnalysis(framework, length(framework$Analyses),
                                       time = data$Time, RR = data$RR,
                                       SBP = data$SBP)
        RAW <- AddAnalysis(RAW, name = names[[n]])
        RAW <- AddDataToAnalysis(RAW, length(RAW$Analyses),
                                 time = data$Time, RR = data$RR,
                                 SBP = data$SBP)
        framework <- AnalyzeTransferFun(framework, length(framework$Analyses))
        framework <- AddAvgCwtData(framework, length(framework$Analyses))
        framework <- AddCausalCoupling(framework, length(framework$Analyses))
        if(length(framework$ExpectedVals) > 0){
          framework <- PrepareIntervalSlots(framework, "dwt")
          framework <- PrepareIntervalSlots(framework, "cwt")
        }
      }
      output$data_file <- renderUI({
        fileInput("data_file", "Upload data file",
                  multiple = TRUE, accept = c("text/csv",
                                               "text/comma-separated-values", "text/plain",
                                               ".csv", ".txt"))
      })
      new_analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      updateSelectInput(session, "subject_input", "Select Subject", choices = new_analysis_choices)
      database$framework <- framework
      RAW_database$RAW <- RAW
      text_n <- paste("Number of subjects contained in this study:", isolate(database$framework)$n, "subjects.")  
      output$text_n <- renderText({text_n})
      
    }
    })
  
  # Load Clinical Data
  
  observeEvent(input$load_clin, {
    framework <- isolate(database$framework)
    req(input$clinic_file)
        if(tools::file_ext(input$study_file$datapath) == "csv"){
          data <- read.csv(input$study_file$datapath,
                           header = TRUE, sep = input$separator,
                           quote  ="")
        } else if(tools::file_ext(input$study_file$datapath) == "txt"){
          data <- read.table(input$study_file$datapath, header = TRUE)
        }
        framework$Clinical <- data
        database$framework <- framework
      output$clinic_file <- renderUI({
        fileInput("clinic_file", "Upload clinical data",
                  multiple = FALSE, accept = c("text/csv",
                                              "text/comma-separated-values", "text/plain",
                                              ".csv", ".txt"))
      })
      new_analysis_choices <- colnames(data)[-1]
      updateSelectInput(session, "select_variable3", "Select clinical variable", choices = c("No clinical variable has been selected",
                                                                                             new_analysis_choices))
  })
  
  #Model clinical data
  
  observeEvent(input$make_linear, {
    framework <- isolate(database$framework)
    if((input$select_variable2 !="No variable has been selected") &
       (input$select_variable3 !="No clinical variable has been selected")){
      if(input$select_variable1 == "BRS (HF)"){
        type = "BRS"
        band = "HF"
      } else if(input$select_variable1 == "BRS (LF)"){
        type = "BRS"
        band = "LF"
      } else if(input$select_variable1 == "HRV (LF)"){
        type = "HRV"
        band = "LF"
      } else if(input$select_variable1 == "HRV (HF)"){
        type = "HRV"
        band = "HF"
      } else if(input$select_variable1 == "HRV (LF/HF)"){
        type = "HRV"
        band = "LFHF"
      }
      clin <- colnames(framework$Clinical)[-1]
      variable <- match(input$select_variable3, clin) 
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$select_variable2, intervals)
      model <- ModelClinicalData(framework, type = type, band = band, segment = interval, variable = variable)
      output$plot_linear <- renderPlot({
        model$Plot
      })
      output$model_stats <- renderText({
        paste("R-squared value of", round(model$r,4), "with a p-value of", round(model$p,4))
      })
    }
  })
  
  # Make plots change according to subject
  
  output$Raw <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      RAW <- isolate(RAW_database$RAW)
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(RAW, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      raw_data <- RAW$Analyses[[chosen_analysis]]$Data
      raw_data[,"RR"] <- 60000/raw_data[,"RR"]
      result <- ggplot2::ggplot(data = data.frame(raw_data), ggplot2::aes(Time)) +
        ggplot2::geom_line(ggplot2::aes(y = RR, colour = "HR")) + 
        ggplot2::geom_line(ggplot2::aes(y = SBP, colour = "SBP")) +
        ggplot2::theme(axis.title.y = ggplot2::element_blank())
      raw_time <- raw_data[,"Time"]
      Time <- framework$Analyses[[chosen_analysis]]$Data[,"Time"]
      if(max(raw_time) != max(Time) | min(raw_time) != min(Time)){
        result <- result + ggplot2::annotate("rect", fill = "red", 
                                               alpha = 0.5, xmin = 
                                                 min(Time),
                                               xmax = max(Time),
                                               ymin = -Inf, ymax = Inf)
      }
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            result <- result + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            result <- result + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(result)
      } else {
        return(result)
      }
    } 
  })
  
  output$"LF/HF" <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedHRV(framework, chosen_analysis, plotLF = TRUE, plotHF = TRUE, newPlot = FALSE)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  output$HF <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedHRV(framework, chosen_analysis, plotLF = FALSE, plotHF = TRUE, newPlot = FALSE)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  output$LF <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedHRV(framework, chosen_analysis, plotHF = FALSE, plotLF = TRUE, newPlot = FALSE)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  
  


  output$Analyzed_TF_Plot1 <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
    analysis_choices <- ShowIndexes(framework, "analyses")[2,]
    chosen_analysis <- match(input$subject_input, analysis_choices)
    Results <- PlotAnalyzedTF(framework, chosen_analysis, "dwt", newPlot = FALSE, plotLF = FALSE)
    if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
      if(input$interval_input != "No intervals have been set"){
        intervals <- ShowIndexes(framework, "intervals")[2,]
        interval <- match(input$interval_input, intervals)
        if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
          Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                 alpha = 0.5, xmin = 
                                                   framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                 xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                 ymin = -Inf, ymax = Inf)
        }
      }
      if(input$control_input != "No control has been set"){
        intervals <- ShowIndexes(framework, "intervals")[2,]
        interval <- match(input$control_input, intervals)
        if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
          Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                 alpha = 0.5, xmin = 
                                                   framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                 xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                 ymin = -Inf, ymax = Inf)
        }
      }
      return(Results)
    } else {
      return(Results)
    }
    } 
    
  })
  
  output$phase1_cwt <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "cwt.phase", newPlot = FALSE, plotLF = FALSE, thr = input$coherence_val)
      Results <- Results + ggplot2::ylim(-pi, pi)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  output$Analyzed_TF_Plot2 <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "dwt", newPlot = FALSE, plotHF = FALSE)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
        } else {
          return(Results)
        }
      } 
      
  })
  
  output$Analyzed_TF_Plot1_cwt <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "cwt.avg", newPlot = FALSE, plotLF = FALSE, thr = input$coherence_val)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  output$Analyzed_TF_Plot2_cwt <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "cwt.avg", newPlot = FALSE, plotHF = FALSE, thr = input$coherence_val)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  
  output$phase2_cwt <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "cwt.phase", newPlot = FALSE, plotHF = FALSE, thr = input$coherence_val)
      Results <- Results + ggplot2::ylim(-pi, pi)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  output$GC_total <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "coupling", newPlot = FALSE, plotHF = FALSE, thr = input$coherence_val,
                                coupling_index = 1)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  output$GC_LF <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "coupling", newPlot = FALSE, plotHF = FALSE, thr = input$coherence_val,
                                coupling_index = 2)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  output$GC_HF <- renderPlot({
    if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, chosen_analysis, "coupling", newPlot = FALSE, plotLF = FALSE, thr = input$coherence_val,
                                coupling_index  = 2)
      if(input$interval_input != "No intervals have been set" | input$control_input != "No control has been set"){
        if(input$interval_input != "No intervals have been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$interval_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "red", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        if(input$control_input != "No control has been set"){
          intervals <- ShowIndexes(framework, "intervals")[2,]
          interval <- match(input$control_input, intervals)
          if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis])){
            Results <- Results + ggplot2::annotate("rect", fill = "blue", 
                                                   alpha = 0.5, xmin = 
                                                     framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]*60,
                                                   xmax = framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis]*60,
                                                   ymin = -Inf, ymax = Inf)
          }
        }
        return(Results)
      } else {
        return(Results)
      }
    } 
    
  })
  
  
  
  
  
  
  # Plot CWT results:
  
  output$CWT_plot <- renderImage(
    { if(input$subject_input !="No subjects have been loaded"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Results <- PlotAnalyzedTF(framework, index = chosen_analysis, method = "cwt", tem = TRUE, newPlot = FALSE,
                                thr = input$coherence_val)
      return(list(src = Results, contentType = "image/png", width = 1500, height = 400, alt = "CWT Transfer Function"))
    } else {
      blank <- tempfile(fileext = ".png")
      png(filename = blank, width = 1500, height = 400)
      plot(0, type = "l", xlab = "", ylab  ="", xaxt = "n", yaxt = "n")
      dev.off()
      return(list(src = blank, contentType = "image/png", width = 1500, height = 400, alt = "CWT Transfer Function"))
    }} , deleteFile = TRUE)
  # Make table of DWT and CWT estimates:
  
  output$DWT_Estimate_HF<- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$Analyzed_TF_brush1)){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Analysis <- framework$Analyses[[chosen_analysis]]
      tf <- Analysis$BRS$DWT
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      EVals <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                              weight = Data$Weight, use.coherence = Data$Threshold,
                              thr = Data$Coherence)
      paste("Estimate at HF band between", round(ifelse(input$Analyzed_TF_brush1$xmin > 0,  input$Analyzed_TF_brush1$xmin/ 60, 0), 3), "and", round(input$Analyzed_TF_brush1$xmax / 60, 3), "min:", round(EVals[1],3), "ms/mmHg")
    }
    })
  
  output$CWT_Estimate_HF<- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$Analyzed_TF_brush1)){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Analysis <- framework$Analyses[[chosen_analysis]]
      tf <- AssembleCwtTransferFun(framework, chosen_analysis)
      if(input$phase_rest == "Restrict to positive phase difference only"){
        rest <- "pos"
      } else if(input$phase_rest == "Restrict to negative phase difference only"){
        rest <- "neg"
      } else {
        rest <- NULL
      }
      tf <- SplitByCoherence(tf, thr = input$coherence_val, phase.rest = rest)
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      EVals <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                              weight = Data$Weight, use.coherence = Data$Threshold,
                              thr = Data$Coherence)
      paste("Estimate at HF band between", round(ifelse(input$Analyzed_TF_brush1$xmin > 0,  input$Analyzed_TF_brush1$xmin/ 60, 0), 3), "and", round(input$Analyzed_TF_brush1$xmax / 60, 3), "min:", round(EVals[1],3), "ms/mmHg")
    }
  })
  
  output$DWT_Estimate_LF<- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$Analyzed_TF_brush1)){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Analysis <- framework$Analyses[[chosen_analysis]]
      tf <- Analysis$BRS$DWT
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      EVals <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                              weight = Data$Weight, use.coherence = Data$Threshold,
                              thr = Data$Coherence)
      paste("Estimate at LF band between", round(ifelse(input$Analyzed_TF_brush1$xmin > 0,  input$Analyzed_TF_brush1$xmin/ 60, 0), 3), "and", round(input$Analyzed_TF_brush1$xmax / 60, 3), "min:", round(EVals[2],3), "ms/mmHg")
    }
    })
  
  output$CWT_Estimate_LF<- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$Analyzed_TF_brush1)){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Analysis <- framework$Analyses[[chosen_analysis]]
      tf <- Analysis$BRS$AvgCWT
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      tf <- AssembleCwtTransferFun(framework, chosen_analysis)
      if(input$phase_rest == "Restrict to positive phase difference only"){
        rest <- "pos"
      } else if(input$phase_rest == "Restrict to negative phase difference only"){
        rest <- "neg"
      } else {
        rest <- NULL
      }
      tf <- SplitByCoherence(tf, thr = input$coherence_val, phase.rest = rest)
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      EVals <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                              weight = FALSE, use.coherence = Data$Threshold,
                              thr = Data$Coherence)
      paste("Estimate at LF band between", round(ifelse(input$Analyzed_TF_brush1$xmin > 0,  input$Analyzed_TF_brush1$xmin/ 60, 0), 3), "and", round(input$Analyzed_TF_brush1$xmax / 60, 3), "min:", round(EVals[2],3), "ms/mmHg")
    }
  })
  
  
  output$Estimate_HF <- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$brush_raw)){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Analysis <- framework$Analyses[[chosen_analysis]]
      hrv <- Analysis$HRV
      hrv$Time <- Analysis$Data[,1]
      hrv$type <- "TFun_dwt"
      EVals <- ExpectedValues(hrv, c(input$brush_raw$xmin / 60, input$brush_raw$xmax / 60),
                              weight = Data$Weight, use.coherence = Data$Threshold,
                              thr = Data$Coherence)
      paste("Estimate at HF band between", round(ifelse(input$brush_raw$xmin > 0,  input$brush_raw$xmin/ 60, 0), 3), "and", round(input$brush_raw$xmax / 60, 3), "min:", round(EVals[1],3), "ms2")
    }
  })
  
  output$Estimate_LF<- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$brush_raw)){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Analysis <- framework$Analyses[[chosen_analysis]]
      hrv <- Analysis$HRV
      hrv$Time <- Analysis$Data[,1]
      hrv$type <- "TFun_dwt"
      EVals <- ExpectedValues(hrv, c(input$brush_raw$xmin / 60, input$brush_raw$xmax / 60),
                              weight = Data$Weight, use.coherence = Data$Threshold,
                              thr = Data$Coherence)
      paste("Estimate at LF band between", round(ifelse(input$brush_raw$xmin > 0,  input$brush_raw$xmin/ 60, 0), 3), "and", round(input$brush_raw$xmax / 60, 3), "min:", round(EVals[2],3), "ms2")
    }
  })
  
  output$Estimate_HR<- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$brush_raw)){
      framework <- isolate(database$framework)
      RAW <- isolate(RAW_database$RAW)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
      raw <- RAW$Analyses[[chosen_analysis]]$Data
      fun <- list(Time = raw[,"Time"], HR = 60000/raw[,"RR"], SBP = raw[,"SBP"])
      select_time <- fun$Time[(fun$Time >= input$brush_raw$xmin) &
                                 (fun$Time <= input$brush_raw$xmax )]
      select_time <- match(select_time, fun$Time)
      HR <- mean(fun$HR[select_time])
      paste("Mean HR between", round(ifelse(input$brush_raw$xmin > 0,  input$brush_raw$xmin/ 60, 0), 3), "and", round(input$brush_raw$xmax / 60, 3), "min:", round(HR,3), "bpm")
    }
  })
  
  output$Estimate_SBP<- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$brush_raw)){
      framework <- isolate(database$framework)
      RAW <- isolate(RAW_database$RAW)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
      raw <- RAW$Analyses[[chosen_analysis]]$Data
      fun <- list(Time = raw[,"Time"], HR = 60000/raw[,"RR"], SBP = raw[,"SBP"])
      select_time <- fun$Time[(fun$Time >= input$brush_raw$xmin ) &
                                (fun$Time <= input$brush_raw$xmax)]
      select_time <- match(select_time, fun$Time)
      SBP <- mean(fun$SBP[select_time])
      paste("Mean SBP between", round(ifelse(input$brush_raw$xmin > 0,  input$brush_raw$xmin/ 60, 0), 3), "and", round(input$brush_raw$xmax / 60, 3), "min:", round(SBP,3), "mmHg")
    }
  })
  
  output$GC_Estimate_total <- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$Analyzed_TF_brush1)){
      framework <- isolate(database$framework)
      RAW <- isolate(RAW_database$RAW)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
      Analysis <- framework$Analyses[[chosen_analysis]]
      tf <- Analysis$Coupling
      tf <- list(HF = tf$y.leads.x$Total, LF = tf$y.leads.x$Total)
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      EVals1 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                              weight = FALSE, use.coherence = FALSE,
                              thr = Data$Coherence)
      tf$HF = Analysis$Coupling$x.leads.y$Total
      tf$LF = Analysis$Coupling$x.leads.y$Total
      EVals2 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                               weight = FALSE, use.coherence = FALSE,
                               thr = Data$Coherence)
      tf$HF = Analysis$Coupling$Coherence$Total
      tf$LF = Analysis$Coupling$Coherence$Total
      EVals3 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                               weight = FALSE, use.coherence = FALSE,
                               thr = Data$Coherence)
      paste("Mean phase-induced coherence between", round(ifelse(input$Analyzed_TF_brush1$xmin > 0,  input$Analyzed_TF_brush1$xmin/ 60, 0), 3),
            "and", round(input$Analyzed_TF_brush1$xmax / 60, 3), "min:", round(EVals1[1],3), "(SBP leading),",
            round(EVals2[1],3), "(RR leading). Total coherence is", round(EVals3[1],3))
    }
  })
  
  output$GC_Estimate_HF <- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$Analyzed_TF_brush1)){
      framework <- isolate(database$framework)
      RAW <- isolate(RAW_database$RAW)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
      Analysis <- framework$Analyses[[chosen_analysis]]
      tf <- Analysis$Coupling
      tf <- list(HF = tf$y.leads.x$HF, LF = tf$y.leads.x$LF)
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      EVals1 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                              weight =FALSE, use.coherence = FALSE,
                              thr = Data$Coherence)
      tf$HF = Analysis$Coupling$x.leads.y$HF
      tf$LF = Analysis$Coupling$x.leads.y$LF
      EVals2 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                               weight = FALSE, use.coherence = FALSE,
                               thr = Data$Coherence)
      tf$HF = Analysis$Coupling$Coherence$HF
      tf$LF = Analysis$Coupling$Coherence$LF
      EVals3 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                               weight = FALSE, use.coherence = FALSE,
                               thr = Data$Coherence)
      paste("Mean phase-induced coherence at HF band between", round(ifelse(input$Analyzed_TF_brush1$xmin > 0,  
                                                                            input$Analyzed_TF_brush1$xmin/ 60, 0), 3), "and", 
            round(input$Analyzed_TF_brush1$xmax / 60, 3), "min:", round(EVals1[[1]],3), "(SBP leading),", 
            round(EVals2[[1]],3), "(RR leading). Total coherence at HF band is", round(EVals3[[1]],3))
    }
  })
  
  output$GC_Estimate_LF <- renderText({
    if(input$subject_input !="No subjects have been loaded" & !is.null(input$Analyzed_TF_brush1)){
      framework <- isolate(database$framework)
      RAW <- isolate(RAW_database$RAW)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      Data <- framework$"General Data"
      Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
      Data <- framework$"General Data"
      Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
      Analysis <- framework$Analyses[[chosen_analysis]]
      Analysis <- framework$Analyses[[chosen_analysis]]
      tf <- Analysis$Coupling
      tf <- list(HF = tf$y.leads.x$HF, LF = tf$y.leads.x$LF)
      tf$Time <- Analysis$Data[,1]
      tf$type <- "TFun_dwt"
      EVals1 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                               weight =FALSE, use.coherence = FALSE,
                               thr = Data$Coherence)
      tf$HF = Analysis$Coupling$x.leads.y$HF
      tf$LF = Analysis$Coupling$x.leads.y$LF
      EVals2 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                               weight = FALSE, use.coherence = FALSE,
                               thr = Data$Coherence)
      tf$HF = Analysis$Coupling$Coherence$HF
      tf$LF = Analysis$Coupling$Coherence$LF
      EVals3 <- ExpectedValues(tf, c(input$Analyzed_TF_brush1$xmin / 60, input$Analyzed_TF_brush1$xmax / 60),
                               weight = FALSE, use.coherence = FALSE,
                               thr = Data$Coherence)
      paste("Mean phase-induced coherence at LF band between", round(ifelse(input$Analyzed_TF_brush1$xmin > 0,  
                                                                            input$Analyzed_TF_brush1$xmin/ 60, 0), 3), "and", 
            round(input$Analyzed_TF_brush1$xmax / 60, 3), "min:", round(EVals1[[2]],3), "(SBP leading),", 
            round(EVals2[[2]],3), "(RR leading). Total coherence at LF band is", round(EVals3[[2]],3))
    }
  })
  
  
  # Evaluate significance of baroreflex activity difference
  output$pvalue_HF <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        tf <- framework$Analyses[[chosen_analysis]]$BRS$DWT
        tf$Time <- Data$Data[,1]
        tf$type <- "TFun_dwt"
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndBRS(tf, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,1] <= 0.05, "Significant", "No significant")
        if(evaluation[2,1] <= 0.001){
          code <- "***"
        } else if(evaluation[2,1] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,1] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste(sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,1], " ms/mmHg (SE ", evaluation[3,1], " ms/mmHg), with a p value of ", 
                      evaluation[2,1], " (", code, ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_HF_cwt <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        tf <- framework$Analyses[[chosen_analysis]]$BRS$AvgCWT
        tf$Time <- Data$Data[,1]
        tf$type <- "TFun_dwt"
        tf <- AssembleCwtTransferFun(framework, chosen_analysis)
        if(input$phase_rest == "Restrict to positive phase difference only"){
          rest <- "pos"
        } else if(input$phase_rest == "Restrict to negative phase difference only"){
          rest <- "neg"
        } else {
          rest <- NULL
        }
        tf <- SplitByCoherence(tf, thr = input$coherence_val, phase.rest = rest)
        tf$Time <- Data$Data[,1]
        tf$type <- "TFun_dwt"
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndBRS(tf, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,1] <= 0.05, "Significant", "No significant")
        if(evaluation[2,1] <= 0.001){
          code <- "***"
        } else if(evaluation[2,1] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,1] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste(sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,1], " ms/mmHg (SE ", evaluation[3,1], " ms/mmHg), with a p value of ", 
                      evaluation[2,1], " (", code, ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_LF <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        tf <- framework$Analyses[[chosen_analysis]]$BRS$DWT
        tf$Time <- Data$Data[,1]
        tf$type <- "TFun_dwt"
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndBRS(tf, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,2] <= 0.05, "Significant", "No significant")
        if(evaluation[2,2] <= 0.001){
          code <- "***"
        } else if(evaluation[2,2] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,2] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste(sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,2], " ms/mmHg (SE ", evaluation[3,2], " ms/mmHg), with a p value of ", 
                      evaluation[2,2], " (", code , ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_LF_cwt <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        tf <- framework$Analyses[[chosen_analysis]]$BRS$AvgCWT
        tf$Time <- Data$Data[,1]
        tf$type <- "TFun_dwt"
        tf <- AssembleCwtTransferFun(framework, chosen_analysis)
        tf$type <- "TFun_cwt"
        tf <- AssembleCwtTransferFun(framework, chosen_analysis)
        if(input$phase_rest == "Restrict to positive phase difference only"){
          rest <- "pos"
        } else if(input$phase_rest == "Restrict to negative phase difference only"){
          rest <- "neg"
        } else {
          rest <- NULL
        }
        tf <- SplitByCoherence(tf, thr = input$coherence_val, phase.rest = rest)
        tf$Time <- Data$Data[,1]
        tf$type <- "TFun_dwt"
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndBRS(tf, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,2] <= 0.05, "Significant", "No significant")
        if(evaluation[2,2] <= 0.001){
          code <- "***"
        } else if(evaluation[2,2] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,2] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste(sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,2], " ms/mmHg (SE ", evaluation[3,2], " ms/mmHg), with a p value of ", 
                      evaluation[2,2], " (", code , ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_HRV_LF <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        hrv <- framework$Analyses[[chosen_analysis]]$HRV
        hrv$Time <- Data$Data[,1]
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndHRV(hrv, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,2] <= 0.05, "Significant", "No significant")
        if(evaluation[2,2] <= 0.001){
          code <- "***"
        } else if(evaluation[2,2] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,2] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste(sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,2], " ms2 (SE ", evaluation[3,2], " ms2), with a p value of ", 
                      evaluation[2,2], " (", code , ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_HRV_HF <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        hrv <- framework$Analyses[[chosen_analysis]]$HRV
        hrv$Time <- Data$Data[,1]
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndHRV(hrv, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,1] <= 0.05, "Significant", "No significant")
        if(evaluation[2,1] <= 0.001){
          code <- "***"
        } else if(evaluation[2,1] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,1] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste(sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,1], " ms2 (SE ", evaluation[3,1], " ms2), with a p value of ", 
                      evaluation[2,1], " (", code , ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_HRV_LFHF <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        hrv <- framework$Analyses[[chosen_analysis]]$HRV
        hrv$Time <- Data$Data[,1]
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndHRV(hrv, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,3] <= 0.05, "Significant", "No significant")
        if(evaluation[2,3] <= 0.001){
          code <- "***"
        } else if(evaluation[2,3] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,3] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste(sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,3], " (SE ", evaluation[3,3], " ), with a p value of ", 
                      evaluation[2,3], " (", code , ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_HR <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      RAW <- isolate(RAW_database$RAW)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        raw_data <- RAW$Analyses[[chosen_analysis]]$Data
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndRaw(raw_data, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,1] <= 0.05, "Significant", "No significant")
        if(evaluation[2,1] <= 0.001){
          code <- "***"
        } else if(evaluation[2,1] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,1] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste("HR: ", sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,1], " bpm (SE ", evaluation[3,1], " bpm), with a p value of ", 
                      evaluation[2,1], " (", code , ")", sep = "")
        return(text)
      }
      
    }
    
  })
  
  output$pvalue_SBP <- renderText({
    if(input$interval_input != "No intervals have been set" & input$control_input != "No control has been set"){
      framework <- isolate(database$framework)
      RAW <- isolate(RAW_database$RAW)
      analysis_choices <- ShowIndexes(framework, "analyses")[2,]
      chosen_analysis <- match(input$subject_input, analysis_choices)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      interval <- match(input$interval_input, intervals)
      control <- match(input$control_input, intervals)
      if(!is.na(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis]) &
         !is.na(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis])){
        Data <- ExtractDataFromAnalysis(framework, chosen_analysis)
        raw_data <- RAW$Analyses[[chosen_analysis]]$Data
        time_flags1 <- c(framework$ExpectedVals[[interval]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[interval]]$Time_DWT[2,chosen_analysis])
        time_flags2 <- c(framework$ExpectedVals[[control]]$Time_DWT[1,chosen_analysis],
                         framework$ExpectedVals[[control]]$Time_DWT[2,chosen_analysis])
        evaluation <- TestIndRaw(raw_data, time_flags1, time_flags2, weight = framework$`General Data`$Weight)
        sig <- ifelse(evaluation[2,2] <= 0.05, "Significant", "No significant")
        if(evaluation[2,2] <= 0.001){
          code <- "***"
        } else if(evaluation[2,2] <= 0.01){ 
          code <- "**"
        } else if(evaluation[2,2] <= 0.05){ 
          code <- "*"
        } else { 
          code <- "ns"
        }  
        text <- paste("SBP: ", sig, " difference in estimates between interval ", input$control_input, " (set as control) and
                      interval ", input$interval_input, ": ", evaluation[1,2], " mmHg (SE ", evaluation[3,2], " mmHg), with a p value of ", 
                      evaluation[2,2], " (", code , ")", sep = "")
        return(text)
      }
      
    }
    
  })
    
    # Select controls by double-cliking:
  observeEvent(input$dbc_raw, {
    check_brush <- !is.null(input$brush_raw)
    check_subject <- input$subject_input !="No subjects have been loaded"
    check_interval <- input$interval_input != "No intervals have been set"
    if(check_subject & check_interval & check_brush){
      framework <- isolate(database$framework)
      analyses <- ShowIndexes(framework, "analyses")[2,]
      intervals <- ShowIndexes(framework, "intervals")[2,]
      analysis <- match(input$subject_input, analyses)
      interval <- match(input$interval_input, intervals)
      framework <- GetExpectedValues(framework, analysis, interval, 
                                       c(input$brush_raw$xmin / 60, 
                                         input$brush_raw$xmax / 60))
      
      database$framework <- framework
      
      # Plot Estimates calculated from DWT Results 
      
    output$ExpectedVals_DWT_Plot <- renderPlot({
        framework <- isolate(database$framework)
        analyses <- ShowIndexes(framework, "analyses")[2,]
        analysis <- match(input$subject_input, analyses)
        restrict <- NULL
        for(n in 1:length(framework$ExpectedVals)){
            if(length(framework$ExpectedVals[[n]]$DWT) != 0 && 
               !is.na(framework$ExpectedVals[[n]]$DWT[1,analysis])) restrict <- c(restrict, n)
        }
        if(!is.null(restrict)){
           PlotIndexesFromAnalysis(framework, analysis, "dwt", newPlot = FALSE,
                                    restrict = restrict, ymax = input$maxEst_dwt) 
        }
    })
    }
  })
  
  output$ExpectedVals_DWT_Plot <- renderPlot({
    check_subject <- input$subject_input !="No subjects have been loaded"
    check_interval <- input$interval_input != "No intervals have been set"
    if(check_subject & check_interval){
    framework <- isolate(database$framework)
    analyses <- ShowIndexes(framework, "analyses")[2,]
    analysis <- match(input$subject_input, analyses)
    restrict <- NULL
    for(n in 1:length(framework$ExpectedVals)){
      if(length(framework$ExpectedVals[[n]]$DWT) != 0 && 
         !is.na(framework$ExpectedVals[[n]]$DWT[1,analysis])) restrict <- c(restrict, n)
    }
    if(!is.null(restrict)){
      PlotIndexesFromAnalysis(framework, analysis, "dwt", newPlot = FALSE,
                              restrict = restrict, ymax = input$maxEst_dwt) 
    }
    }
  })
  
  # Test Variables
  
  observeEvent(input$confirm_test, {
    check_test <- input$test_var_in_test !="No testing variable has been selected"
    check_con <- input$con_var_in_test != "No control variable has been selected"
    if(check_test & check_con){
      framework <- isolate(database$framework)
      intervals <- ShowIndexes(framework, "intervals")[2,]
      test <- match(input$test_var_in_test , intervals)
      control <- match(input$con_var_in_test, intervals)
      framework <- TestGroups(framework, test, control, name = input$test_name, method = "t.test")
      framework <- TestHRV(framework, test, control, name = input$test_name, method = "t.test", normalize = input$norm_hrv)
      tests <- ShowIndexes(framework, "tests")[2,]
      updateSelectInput(session, "select_testHRV", "Select test", choices = c("No test has been selected", tests))
      updateSelectInput(session, "select_test", "Select test", choices = c("No test has been selected", tests))
      text_ntests <- paste("Number of tests performed:", length(framework$Tests), "tests.")
      output$text_ntests <- renderText({text_ntests})
      database$framework <- framework
    }
    
  })
  
  # Show Testing Results
  
  output$testing_resultsHRV <- renderPlot({
    if(input$select_testHRV != "No test has been selected"){
      framework <- isolate(database$framework)
      tests <- ShowIndexes(framework, "tests")[2,]
      test <- match(input$select_testHRV , tests)
      results <- PlotHRVTestResults(framework, test, newPlot = FALSE)
      return(results)
    }
    
  })
    
  
  output$testing_results <- renderPlot({
    if(input$select_test != "No test has been selected"){
      framework <- isolate(database$framework)
      tests <- ShowIndexes(framework, "tests")[2,]
      test <- match(input$select_test , tests)
      results <- PlotTestResults(framework, test, newPlot = FALSE)
      return(results)
    }
    
  })
    
 
  
}

# Run the application 
shinyApp(ui = ui, server = server)
